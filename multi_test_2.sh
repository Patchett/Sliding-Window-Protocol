#!/bin/sh

rm .output* .debug* .expected*
rm -f ~/.local/share/Trash/.output*
rm -f ~/.local/share/Trash/.debug*
rm -f ~/.local/share/Trash/.expected*

check_output() {
    cmp .output.$1 .expected_output.$1 2>/dev/null >/dev/null
    if [ $? -eq 0 ]
    then
        echo "PASSED"
        #rm $1 $2
    else
        echo "FAILED"
        echo "Output from tritontalk binary is in file: .output.$1"
        echo "Expected output is in file: .expected_output.$1"
        echo "Debug output from tritontalk binary is in file: .debug_output.$1"
    fi
    echo
}
check_multi_output(){
    cmp output$1 expected_output$1 2>/dev/null >/dev/null
    if [ $? -eq 0 ]
    then
        echo "PASSED"
        #rm $1 $2
    else
        echo "FAILED"
        echo "Output from tritontalk binary is in file: .output.$1"
        echo "Expected output is in file: .expected_output.$1"
        echo "Debug output from tritontalk binary is in file: .debug_output.$1"
    fi
    echo

}



echo "###########################################################################"

echo "NOTE: Guidelines for using this script:"

echo "      - Tests check output written to stdout only."

echo "        If you have debug output in stdout, it may cause test failures."

echo "      - This is not a comprehensive set of test cases."

echo "        It is intended to help you do basic checks on your project."

echo "      - If your program fails any test, it will print the output files"

echo "        generated by your program and the output expected for the test case."

echo "      - The script should take about 20 seconds to complete."

echo "###########################################################################"

echo

echo

echo "Rebuilding tritontalk..."

make clean; make -j4 tritontalk

echo "Done rebuilding tritontalk"

echo

# ## Test Case 1

# echo -n "Test case 1: Sending 1 packet and expecting receiver to print it out: "
# (sleep 0.5; echo "msg 0 0 Hello world"; sleep 0.5; echo "exit") | valgrind --tool=memcheck --leak-check=yes --show-reachable=yes --num-callers=20 --track-fds=yes ./tritontalk -r 1 -s 1 > .output.1 2> .debug_output.1
# cat > .expected_output.1 << EOF
# <RECV_0>:[Hello world]
# EOF
# check_output 1

# ## Test Case 2

# echo -n "Test case 2: Sending 10 packets and expecting receiver to print them out in order: "
# (sleep 0.5; for i in `seq 0 9`; do echo "msg 0 0 Packet: $i"; sleep 0.1; done; sleep 1; echo "exit") | valgrind --tool=memcheck --leak-check=yes --show-reachable=yes --num-callers=20 --track-fds=yes ./tritontalk -r 1 -s 1 > .output.2 2> .debug_output.2
# (for i in `seq 0 9`; do echo "<RECV_0>:[Packet: $i]"; done) > .expected_output.2
# check_output 2

# ## Test Case 3

# echo -n "Test case 3: Sending 30 packets (with corrupt probability of 40%) and expecting receiver to print them out in order: "
# (sleep 0.5; for i in `seq 0 9`; do echo "msg 0 0 Packet: $i"; sleep 0.1; done; sleep 30; echo "exit") | ./tritontalk -c 0.4 -r 1 -s 1 > .output.3 2> .debug_output.3
# (for i in `seq 0 9`; do echo "<RECV_0>:[Packet: $i]"; done) > .expected_output.3
# check_output 3

# ## Test Case 4

# echo -n "Test case 4: Sending 10 packets (with corrupt probability of 20% and drop probability of 20%) and expecting receiver to print them out in order: "
# (sleep 0.5; for i in `seq 0 9`; do echo "msg 0 0 Packet: $i"; sleep 0.1; done; sleep 5; echo "exit") | ./tritontalk -d 0.2 -c 0.2 -r 1 -s 1 > .output.4 2> .debug_output.4
# (for i in `seq 0 9`; do echo "<RECV_0>:[Packet: $i]"; done) > .expected_output.4
# check_output 4

# ## drop only

# echo -n "Test case 5: Sending 300 packets with drop prob of 50% and expecting receiver to print them out in order: "
# (sleep 0.5; for i in `seq 0 299`; do echo "msg 0 0 Packet: $i"; sleep 0.1; done; sleep 35; echo "exit") | ./tritontalk -r 1 -s 1 -d 0.5 > .output.5 2> .debug_output.5
# (for i in `seq 0 299`; do echo "<RECV_0>:[Packet: $i]"; done) > .expected_output.5
# check_output 5

# ## corrupt only

# echo -n "Test case 6: Sending 300 packets with corrupt prob of 40% and expecting receiver to print them out in order: "
# (sleep 0.5; for i in `seq 0 299`; do echo "msg 0 0 Packet: $i"; sleep 0.1; done; sleep 35; echo "exit") | ./tritontalk -r 1 -s 1 -c 0.4 > .output.6 2> .debug_output.6
# (for i in `seq 0 299`; do echo "<RECV_0>:[Packet: $i]"; done) > .expected_output.6
# check_output 6

## no corrupt or drop

echo -n "Test case 7: Sending 300 packets with corrupt and drop rates of 40% and expecting receiver to print them out in order: "
(sleep 0.5; for i in `seq 0 299`; do echo "msg 0 0 Sender: 0 Packet: $i"; sleep 0.1; echo "msg 1 1 Sender: 1 Packet: $i"; sleep 0.1; done; sleep 100; echo "exit") | ./tritontalk -r 3 -s 3 -c 0.4 -d 0.4 > .output.7 2> .debug_output.7
(for i in `seq 0 299`; do echo "<RECV_0>:[Sender: 0 Packet: $i]"; done) > expected_output0
(for i in `seq 0 299`; do echo "<RECV_1>:[Sender: 1 Packet: $i]"; done) > expected_output1
grep '<RECV_0>' .output.7 > output0
grep '<RECV_1>' .output.7 > output1

check_multi_output 0
check_multi_output 1

# ## corrupt and drop

# echo -n "Test case 8: Sending 300 packets with corrupt prob of 50% and drop prob of 50% expecting receiver to print them out in order: "
# (sleep 0.5; for i in `seq 0 299`; do echo "msg 0 0 Packet: $i"; sleep 0.1; done; sleep 100; echo "exit") | ./tritontalk -r 1 -s 1 -c 0.5 -d 0.5 > .output.8 2> .debug_output.8
# (for i in `seq 0 299`; do echo "<RECV_0>:[Packet: $i]"; done) > .expected_output.8
# check_output 8

# ## drop 30 only

# echo -n "Test case 9: Sending 30 packets with drop prob of 40% expecting receiver to print them out in order: "
# (sleep 0.5; for i in `seq 0 29`; do echo "msg 0 0 Packet: $i"; sleep 0.1; done; sleep 35; echo "exit") | ./tritontalk -r 1 -s 1 -d 0.4 > .output.9 2> .debug_output.9
# (for i in `seq 0 29`; do echo "<RECV_0>:[Packet: $i]"; done) > .expected_output.9
# check_output 9

echo
echo "Completed test cases"
